title: 组件规范
date: 2015-12-24 23:19:45
categories:
- 前端规范
---

## 组件的管理的策略

Browserify + npm

一个前端的组件就是一个 nodeJs 的 module。所以写一个前端组件的方式就和写一个nodeJs 模块的方式是一样的。模块的引用方式也是相同的。

按理来说来说组件应该使用 npm 管理，但是由于目前 npm 的私有库还没有部署。我们采用折中的方式，使用 git 来手动载入组件。在下面的操作步骤中会具体介绍。

## 组件的目录规范

首先来看一个项目目录
- project
    + dist
    + src
    + node_modules
        * jquery
        * myplug

组件是放在node_modules目录下的，放在node_modules下的组件 在文件中可以直接引用，而不用添加目录。
```javascript
var $ = require('jquery');
var myplug = require('myplug');

```

### 组件内部的目录

组件内部的目录可以根据需要灵活改变

#### 简单组件的目录

如果组件比较简单只有一个文件，就采用下面的目录

- myplug
    + myplug.js
    + demo
    + package.json
    + readme.md

demo 目录下写组件使用的样例；readme.md文件中写组件的用法；

package.json文件中指明组件的必要信息，比如:组件的名字、组件的描述、组件的版本号、组件的主文件、组件的依赖等。
```json
{
  "name": "myplug",
  "description": "JavaScript library for DOM operations",
  "version": "2.1.4",
  "main": "dist/jquery.js",
  "dependencies": {}
}

```

#### 复杂的组件目录

如果组件非常复杂，需要进行构建

- myplug
    + dist
        * myplug.js
    + src 
        * myplug.js
        * otherfile
    + demo
    + package.json
    + readme.md

## 组件内容的模块化支持

为了适应当前的模块化策略，我们只需要加上[CommonJS](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)模块化支持，但是为了适应[各种模块化策略](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)，让组件更加通用，我们为模块加上AMD,CMD的模块化支持。模块化支持的代码如下：

```javascript
(function() {

    var myPlug = {}

    /* 模块化策略兼容代码 */
    if (typeof module !== 'undefined' && typeof exports === 'object') {
        module.exports = myPlug;
    } else if (typeof define === 'function' && (define.amd || define.cmd)) {
        define(function() {
            return myPlug;
        });
    } else {
        window.myPlug = myPlug;
    }
}())
```

这样以来，不管是使用 seaJs 还是 requireJs 做模块化，我们都能轻松引入我们的插件了。