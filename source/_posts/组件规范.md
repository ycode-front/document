title: 组件规范
date: 2015-12-24 23:19:45
categories:
- 前端规范
---

## 组件的管理的策略

Browserify + npm

一个前端的组件就是一个 nodeJs 的 module。所以写一个前端组件的方式就和写一个nodeJs 模块的方式是一样的。模块的引用方式也是相同的。

按理来说来说组件应该使用 npm 管理，但是由于目前 npm 的私有库还没有部署。我们采用折中的方式，使用 git 来手动载入组件。在下面的操作步骤中会具体介绍。

## 组件的目录规范

首先来看一个项目目录
- project
    + dist
    + src
    + node_modules
        * jquery
        * myplug

组件是放在node_modules目录下的，放在node_modules下的组件 在文件中可以直接引用，而不用添加目录。
```javascript
var $ = require('jquery');
var myplug = require('myplug');

```

### 组件内部的目录

组件内部的目录可以根据需要灵活改变

#### 简单组件的目录

如果组件比较简单只有一个文件，就采用下面的目录

- myplug
    + myplug.js
    + demo
    + package.json
    + readme.md

demo 目录下写组件使用的样例；readme.md文件中写组件的用法；

package.json文件中指明组件的必要信息，比如:组件的名字、组件的描述、组件的版本号、组件的主文件、组件的依赖等。
```json
{
  "name": "myplug",
  "description": "JavaScript library for DOM operations",
  "version": "2.1.4",
  "main": "dist/jquery.js",
  "dependencies": {}
}

```

#### 复杂的组件目录

如果组件非常复杂，需要进行构建

- myplug
    + dist
        * myplug.js
    + src 
        * myplug.js
        * otherfile
    + demo
    + package.json
    + readme.md

## 组件内容的模块化支持

为了适应当前的模块化策略，我们只需要加上[CommonJS](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)模块化支持，~~但是为了适应[各种模块化策略](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)，让组件更加通用，我们为模块加上AMD,CMD的模块化支持。模块化支持的代码如下：~~，同时组件也兼容没有模块化策略下的使用。

组件的定义分为下面三种，一一列举

一. 不依赖jQuery的组件

```javascript
(function() {
    // 对模块引入做兼容
    if(typeof require === 'undefined'){
        var require = function(moduleName){
            return window[moduleName];
        }
    }
    
    // 引入一个插件
    var depplug = require('depplug');

    var Main = {};

    /* 模块化策略兼容代码 */
    if (typeof module !== 'undefined' && typeof exports === 'object') {
        module.exports = Main;
    }else {
        window.plugname = Main;
    }

}())
```

二. 依赖jQuery的组件

```javascript
// 如果你的组件依赖jquery
$(function(){
    // 对依赖的引入做兼容
    if(typeof require === 'undefined'){
        var require = function(moduleName){
            return window[moduleName];
        }
    }
    
    // 引入一个插件
    var depplug = require('depplug');


    var Main = {};

    /* 模块化策略兼容代码 */
    if (typeof module !== 'undefined' && typeof exports === 'object') {
        module.exports = Main;
    }else {
        window.plugname = Main;
    }
})
```

三. jQuery插件

由于jQuery插件是挂载在jQuery全局变量下的，所以模块无需导出，在引用jQuery插件的时候也无需接收。

```javascript
$(function() {
    // 对依赖的引入做兼容
    if(typeof require === 'undefined'){
        var require = function(moduleName){
            return window[moduleName];
        }
    }

    // 引入一个jquery插件
    require('depjQueryPlug');

    var Main = {};


    // 扩展全局变量
    $.extend({
        plugname: function() {

        }
    })

    // 扩展原型
    $.fn.extend({
        plugname: function() {

        }
    });

})
```
